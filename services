
/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
*/

import { GoogleGenAI, GenerateContentResponse, Modality } from "@google/genai";
import { HistoricalScenario, Source } from "../types";
import { decodeBase64, decodeAudioData } from "../utils/audioUtils";

const FLASH_MODEL = 'gemini-3-flash-preview'; 
const TTS_MODEL = 'gemini-2.5-flash-preview-tts';
const IMAGE_MODEL = 'gemini-2.5-flash-image';

function extractJSON(text: string): any {
  let jsonString = text.trim().replace(/```json/gi, '').replace(/```/g, '');
  const firstOpen = jsonString.indexOf('{');
  const lastClose = jsonString.lastIndexOf('}');
  if (firstOpen === -1 || lastClose === -1) throw new Error("Respuesta del servidor inválida.");
  return JSON.parse(jsonString.substring(firstOpen, lastClose + 1));
}

export async function researchLocationAndDate(location: string, date: string): Promise<HistoricalScenario> {
  const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });

  const prompt = `
    Como historiador magistral de México, investiga: "${location}" ${date ? `en la fecha o época ${date}` : ""}.
    
    REGLAS ESTRICTAS DE LENGUAJE (DECISIÓN BASADA EN ÉPOCA):
    1. SI el evento es ANTES de 1521: El campo "text" DEBE estar en la lengua originaria (Náhuatl, Maya, Mixteco, etc.) y "translation" en español.
    2. SI el evento es DESPUÉS de 1521: El campo "text" DEBE estar en ESPAÑOL DE LA ÉPOCA. Solo usa lengua originaria si el personaje es un líder indígena específico que no hablaba español.
    3. NO uses náhuatl para personajes del siglo XIX o XX (ej. Benito Juárez, Porfirio Díaz, Zaragoza deben hablar en ESPAÑOL).

    REGLAS DE IDENTIDAD Y VOZ:
    - Identifica a 2 protagonistas históricos reales con su género correcto.
    - HOMBRES: Usa 'Charon' o 'Puck' (Voces graves/masculinas).
    - MUJERES: Usa 'Kore' o 'Aoede' (Voces agudas/femeninas).
    - ASEGÚRATE: Un general o soldado masculino NUNCA debe tener voz 'Kore' o 'Aoede'.

    JSON:
    {
      "context": "Breve descripción épica del momento.",
      "accentProfile": "Atmósfera sonora y estilo de habla.",
      "characters": [
        {
          "name": "Nombre Real", 
          "gender": "male|female", 
          "voice": "Charon|Puck|Kore|Aoede", 
          "visualDescription": "Descripción para retrato al óleo",
          "bio": "Breve rol histórico"
        }
      ],
      "script": [
        {
          "speaker": "Nombre Real", 
          "text": "Diálogo original (Indígena solo si es < 1521, sino Español)", 
          "translation": "Traducción al español actual"
        }
      ]
    }
  `;

  const response = await ai.models.generateContent({
    model: FLASH_MODEL,
    contents: prompt,
    config: { 
      tools: [{ googleSearch: {} }],
      responseMimeType: "application/json"
    }
  });

  const groundingChunks = response.candidates?.[0]?.groundingMetadata?.groundingChunks || [];
  const sources = groundingChunks
    .filter((c: any) => c.web?.uri)
    .map((c: any) => ({ title: c.web.title || "Fuente", uri: c.web.uri }))
    .slice(0, 3);

  const data = extractJSON(response.text);
  return { ...data, sources };
}

export async function generateDialogueAudio(scenario: HistoricalScenario): Promise<AudioBuffer> {
  const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });

  // Mapeo robusto de locutores basado en los nombres de voz elegidos por el modelo
  const speakerVoiceConfigs = scenario.characters.slice(0, 2).map((char, i) => {
    // Validar nombre de voz y capitalizar
    let voiceName = char.voice || (char.gender === 'female' ? 'Kore' : 'Charon');
    voiceName = voiceName.charAt(0).toUpperCase() + voiceName.slice(1).toLowerCase();
    
    return {
      speaker: `Actor_${i}`,
      voiceConfig: { prebuiltVoiceConfig: { voiceName } }
    };
  });

  let dialogueText = "";
  scenario.script.forEach(line => {
    const charIdx = scenario.characters.findIndex(c => c.name === line.speaker);
    const speakerTag = `Actor_${charIdx === -1 ? 0 : charIdx}`;
    dialogueText += `${speakerTag}: ${line.text}\n`;
  });

  const response = await ai.models.generateContent({
    model: TTS_MODEL, 
    contents: [{ parts: [{ text: dialogueText }] }],
    config: {
      responseModalities: [Modality.AUDIO], 
      speechConfig: { 
        multiSpeakerVoiceConfig: { 
          speakerVoiceConfigs: speakerVoiceConfigs.length === 2 ? speakerVoiceConfigs : [
            ...speakerVoiceConfigs,
            { speaker: 'Actor_Placeholder', voiceConfig: { prebuiltVoiceConfig: { voiceName: 'Zephyr' } } }
          ]
        } 
      }
    }
  });

  const base64 = response.candidates?.[0]?.content?.parts?.find(p => p.inlineData)?.inlineData?.data;
  if (!base64) throw new Error("La señal de audio es demasiado débil.");
  
  const ctx = new (window.AudioContext || (window as any).webkitAudioContext)({ sampleRate: 24000 });
  const buffer = await decodeAudioData(decodeBase64(base64), ctx, 24000, 1);
  await ctx.close();
  return buffer;
}

export async function generateCharacterAvatar(description: string): Promise<string | null> {
  const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
  try {
    const response = await ai.models.generateContent({
      model: IMAGE_MODEL,
      contents: { parts: [{ text: `Authentic historical oil painting portrait, professional lighting: ${description}` }] }
    });
    const part = response.candidates?.[0]?.content?.parts?.find(p => p.inlineData);
    return part ? `data:image/png;base64,${part.inlineData.data}` : null;
  } catch { return null; }
}
